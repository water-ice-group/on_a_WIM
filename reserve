    


################################ OLD WillardChandler.py CODE ################################

    # def save_inter_h2o(self): 
        
    #     '''Save the interfacial water for visualisation.'''
        
    #     itim = monolayer(self._u,self._start,self._end) 
    #     itim.save_coords()


    # def surface_rdf(self,bins): # calculate RDF of surface water
        
    #     '''Calculate the radial distribution function of the interfacial water.'''

    #     itim = monolayer(self._u,self._start,self._end)
    #     cluster_prop = monolayer_properties(self._u)
    #     inter_ox,inter_h1,inter_h2 = itim.surf_positions_single_interface(self._boxdim)
    #     num_cores = int(multiprocessing.cpu_count())
    #     result = Parallel(n_jobs=num_cores,backend='threading')(delayed(cluster_prop.calc_OW_C_RDF)(inter_ox[i],self._cpos[i],self._boxdim[i]) for i in tqdm(range(len(inter_ox))))
    #     hist_input = np.concatenate(result).ravel()
    #     norm=True
    #     density,x_range = np.histogram(hist_input,bins=bins,
    #                                 density=norm,range=(1,10))
    #     density = [density[i]/(2*np.pi*x_range[i]) for i in range(len(density))]
    #     save_dat = np.array([x_range[:-1],density])
    #     save_dat = save_dat.transpose()
    #     np.savetxt(f'./outputs/surf_RDF.dat',save_dat)
    #     return (density,x_range[:-1])
    



    # def Cluster_distances(self,property='dip_C',bins=100):

    #     '''Identify distances of closest approach between 
    #     two sets of molecules.'''

    #     itim = monolayer(self._u,self._start,self._end)
    #     cluster_prop= monolayer_properties(self._u)

    #     inter_ox,inter_h1,inter_h2 = itim.surf_positions_single_interface(self._boxdim)
        
    #     if property=='dip_C': # distance between water dipole and carbon
    #         num_cores = int(multiprocessing.cpu_count())
    #         result = Parallel(n_jobs=num_cores,backend='threading')(delayed(cluster_prop.calc_dip_C_angle)(inter_ox[i],inter_h1[i],inter_h2[i],self._cpos[i],self._boxdim[i]) for i in tqdm(range(len(inter_ox))))
    #         dist = [i[0] for i in result]
    #         hist_input = np.concatenate(dist).ravel()
    #         norm=True
    #     elif property=='OW_OC': # distance between water oxygen and carbon
    #         num_cores = int(multiprocessing.cpu_count())
    #         result = Parallel(n_jobs=num_cores,backend='threading')(delayed(cluster_prop.OW_OC_dist)(inter_ox[i],self._ocpos1[i],self._ocpos2[i],self._boxdim[i]) for i in tqdm(range(len(inter_ox))))
    #         dist = result
    #         hist_input = np.concatenate(dist).ravel()
    #         norm=True

    #     density,x_range = np.histogram(hist_input,bins=bins,
    #                                 density=norm,range=(1,8))
    #     save_dat = np.array([x_range[:-1],density])
    #     save_dat = save_dat.transpose()
    #     np.savetxt(f'./outputs/cluster_{property}_distance.dat',save_dat)
    #     return (density,x_range[:-1])


    # def Cluster_orientations(self,property='water_dipole',bins=100):

    #     '''Calculate angles of interest pertaining to interfacial
    #     water molecules.'''

    #     itim = monolayer(self._u,self._start,self._end)
    #     cluster_prop = monolayer_properties(self._u)

    #     inter_ox,inter_h1,inter_h2 = itim.surf_positions_single_interface(self._boxdim)

    #     if property=='water_dipole': # angle between water dipole and WC vector connecting to instantaneous interface
    #         dens = Density(self._u)
    #         num_cores = int(multiprocessing.cpu_count())
    #         result = Parallel(n_jobs=num_cores,backend='threading')(delayed(cluster_prop.calc_h2o_dipole_angle)(inter_ox[i],inter_h1[i],inter_h2[i],self._WC[i],self._boxdim[i]) for i in tqdm(range(len(inter_ox))))
    #         theta = [i[1] for i in result]  
    #         hist_input = np.concatenate(theta).ravel()
    #         norm = True
    #     elif property=='OH_bonds': # angle between hydrogen bond vectors and WC vector connecting to instantaneous interface
    #         num_cores = int(multiprocessing.cpu_count())
    #         result = Parallel(n_jobs=num_cores,backend='threading')(delayed(cluster_prop.calc_OH_vect_angles)(inter_ox[i],inter_h1[i],inter_h2[i],self._WC[i],self._boxdim[i]) for i in tqdm(range(len(inter_ox))))
    #         theta = result
    #         hist_input = np.concatenate(theta).ravel()
    #         norm = True
    #     elif property=='dip_C': # angle between water dipole and nearest carbon
    #         num_cores = int(multiprocessing.cpu_count())
    #         result = Parallel(n_jobs=num_cores,backend='threading')(delayed(cluster_prop.calc_dip_C_angle)(inter_ox[i],inter_h1[i],inter_h2[i],self._cpos[i],self._boxdim[i]) for i in tqdm(range(len(inter_ox))))
    #         theta = [i[1] for i in result]  
    #         hist_input = np.concatenate(theta).ravel()
    #         norm = True
    #     elif property=='OW_OC': # angle between water oxygen and nearest carbon
    #         dens = Density(self._u)
    #         num_cores = int(multiprocessing.cpu_count())
    #         result = Parallel(n_jobs=num_cores,backend='threading')(delayed(cluster_prop.OW_OC_angle)(inter_ox[i],self._ocpos1[i],self._ocpos2[i],self._WC[i],self._boxdim[i]) for i in tqdm(range(len(inter_ox))))
    #         hist_input = np.concatenate(result).ravel()
    #         norm = True

    #     density,x_range = np.histogram(hist_input,bins=bins,
    #                                 density=norm,
    #                                 range=(0,180)
    #                                 )
    #     output = [density[i]/( 0.5*np.sin((x_range[i]*(np.pi / 180))) ) for i in range(len(x_range[:-1]))] # divide by the isotropic distribution
    #     save_dat = np.array([x_range[:-1],output])
    #     save_dat = save_dat.transpose()
    #     np.savetxt(f'./outputs/cluster_{property}_angle.dat',save_dat)
    #     return (output,x_range[:-1])




    # def surf_co2(self,property='rdf',min_cutoff=0,max_cutoff=4,bins=100,norm=True):

    #     '''Calculate properties of CO2 molecules at the interface.

    #     min_cutoff: minimum cutoff for locatinng CO2. 
    #     max_cutoff: maximum cutoff for locating CO2.'''

    #     itim = monolayer(self._u,self._start,self._end)
    #     cluster_prop = monolayer_properties(self._u)

    #     num_cores = int(multiprocessing.cpu_count())
    #     if property=='rdf':
    #         result = Parallel(n_jobs=num_cores,backend='threading')(delayed(cluster_prop.co2_surf_dist)(self._WC[i],self._cpos[i],self._boxdim[i],min_cutoff,max_cutoff) for i in tqdm(range(len(self._cpos))))
    #         hist_input = np.concatenate(result).ravel()
    #         density,x_range = np.histogram(hist_input,bins=bins,
    #                         density=norm,range=(1,10))
    #         #output = [density[i]/(2*np.pi*x_range[i]) for i in range(len(density))] # convert to RDF
    #         output = [density[i]/(4*np.pi*x_range[i]**2) for i in range(len(density))] # convert to RDF
    #         #output = density
    #     elif property=='CO_angle':
    #         result = Parallel(n_jobs=num_cores,backend='threading')(delayed(cluster_prop.co2_bond_angles_surf)(self._WC[i],self._cpos[i],self._ocpos1[i],self._ocpos2[i],self._boxdim[i],min_cutoff,max_cutoff) for i in tqdm(range(len(self._cpos))))
    #         hist_input = np.concatenate(result).ravel()
    #         density,x_range = np.histogram(hist_input,bins=bins,
    #                         density=norm,range=(1,180))
    #         output = [density[i]/( 0.5*np.sin((x_range[i]*(np.pi / 180))) ) for i in range(len(x_range[:-1]))]
                
    #     save_dat = np.array([x_range[:-1],output])
    #     save_dat = save_dat.transpose()
    #     np.savetxt(f'./outputs/surf_co2_{property}.dat',save_dat)
    #     return (output,x_range[:-1])





    # def Hbond_prop(self,bins=100):

    #     itim = monolayer(self._u,self._start,self._end)
    #     cluster_prop = monolayer_properties(self._u)

    #     inter_ox,inter_h1,inter_h2 = itim.surf_positions_single_interface(self._boxdim)

    #     # obtain distances and angles
    #     num_cores = int(multiprocessing.cpu_count())
    #     result = Parallel(n_jobs=num_cores,backend='threading')(delayed(cluster_prop.hbond_properties)(inter_ox[i],inter_h1[i],inter_h2[i],self._ocpos1[i],self._ocpos2[i],self._boxdim[i]) for i in tqdm(range(len(inter_ox))))
    #     dist = [i[0] for i in result]
    #     ang  = [i[1] for i in result]

    #     # distance hist
    #     hist_input = np.concatenate(dist).ravel()
    #     norm=True
    #     density_dist,x_range_dist = np.histogram(hist_input,bins=bins,
    #                                 density=norm,range=(1,10))
    #     save_dat = np.array([x_range_dist[:-1],density_dist])
    #     save_dat = save_dat.transpose()
    #     np.savetxt(f'./outputs/hbonding_dist_surf.dat',save_dat)
        

    #     # angle hist
    #     hist_input = np.concatenate(ang).ravel()
    #     norm=True
    #     density_ang,x_range_ang = np.histogram(hist_input,bins=bins,
    #                                 density=norm,range=(1,180))
    #     output = [density_ang[i]/( 0.5*np.sin((x_range_ang[i]*(np.pi / 180))) ) for i in range(len(x_range_ang[:-1]))]
    #     save_dat = np.array([x_range_ang[:-1],output])
    #     save_dat = save_dat.transpose()
    #     np.savetxt(f'./outputs/hbonding_ang_surf.dat',save_dat)

    #     return ((density_dist,x_range_dist[:-1]),(density_ang,x_range_ang[:-1]))

























################################ OLD itim.py CODE ################################
    

    #####################################################################################################

    # def calc_h2o_dipole_angle(self,ox,h1,h2,wc,boxdim):

    #     '''Calculate the angle between the water's dipole and the 
    #     vector connecting the molecule to the instantaneous
    #     interface. Select layer using the monolayer class.'''

    #     dipVector = self.get_dipoles(ox,h1,h2,boxdim)
        
        
    #     dist,surf_vect = Density(self._u).proximity(wc,ox,boxdim,result='both',cutoff=False)
        
        
    #     theta = self.calc_angles(dipVector,surf_vect)
        

    #     return (dist,theta)
    

    # def calc_OH_vect_angles(self,ox,h1,h2,wc,boxdim):

    #     vect1,vect2 = self.get_OH_vects(ox,h1,h2,boxdim)
    #     dist,surf_vect_1 = Density(self._u).proximity(wc,ox,boxdim,result='both',cutoff=False)
        
    #     theta_1 = self.calc_angles(vect1,surf_vect_1)
    #     theta_2 = self.calc_angles(vect2,surf_vect_1)
    #     output = np.concatenate((theta_1,theta_2))

    #     return output



    # def calc_dip_C_angle(self,ox,h1,h2,cpos,boxdim):

    #     '''Calculate the angle between the water's dipole and the 
    #     closest carbon.'''

    #     dipVector = self.get_dipoles(ox,h1,h2,boxdim)
    #     interm_dist,interm_vect = self.get_closest_vect(ox,cpos,boxdim)

    #     theta = self.calc_angles(dipVector,interm_vect)

    #     return (interm_dist,theta)


    
    # def calc_OW_C_RDF(self,inter_ox,cpos,boxdim):

    #     '''Calculate the angle between the water's dipole and the 
    #     closest carbon.'''

    #     dist_mat = distance_array(inter_ox,cpos,box=boxdim)
    #     output = np.concatenate(dist_mat).ravel()
        
    #     return output
    


    # def OW_OC_dist(self,ox,ocpos1,ocpos2,boxdim):

    #     '''Combine the co2 oxygens at each frame. Plug into function to extract distances.
    #     OW-OC distance important in gauging the number of hydrogen bonds at an interface.'''

    #     ocpos_comb = []
    #     for i in range(len(ocpos1)):
    #         ocpos_comb.append(ocpos1[i])
    #         ocpos_comb.append(ocpos2[i])

    #     ocpos_comb = np.array(ocpos_comb)

    #     interm_dist,interm_vect = self.get_closest_vect(ox,ocpos_comb,boxdim)

    #     return interm_dist

    # def OW_OC_angle(self,ox,ocpos1,ocpos2,wc,boxdim):

    #     '''Combine the co2 oxygens at each frame. Plug into function to extract distances.
    #     OW-OC distance important in gauging the number of hydrogen bonds at an interface.'''

    #     ocpos_comb = []
    #     for i in range(len(ocpos1)):
    #         ocpos_comb.append(ocpos1[i])
    #         ocpos_comb.append(ocpos2[i])

    #     ocpos_comb = np.array(ocpos_comb)

    #     interm_dist,interm_vect = self.get_closest_vect(ox,ocpos_comb,boxdim)
    #     dist,surf_vect = Density(self._u).proximity(wc,ox,boxdim,result='both',cutoff=False)

    #     theta = self.calc_angles(interm_vect,surf_vect)


    #     return theta

    # def hbond_properties(self,ox,h1,h2,ocpos1,ocpos2,boxdim):

    #     ocpos_comb = []
    #     for i in range(len(ocpos1)):
    #         ocpos_comb.append(ocpos1[i])
    #         ocpos_comb.append(ocpos2[i])
    #     ocpos_comb = np.array(ocpos_comb)

    #     interm_dist,loc = self.get_closest_vect(ox,ocpos_comb,boxdim,locr=True) # first value returned gives distances. 
    #     #print(loc)


    #     angles = []
    #     for i in range(len(ox)):

    #         oxpos = ox[i]
    #         hpos = [h1[i],h2[i]]
    #         hpos = np.array(hpos)

    #         dist_mat = distance_array(ocpos_comb[loc[i]],hpos)
    #         proxim = np.min(dist_mat,axis=1)            
    #         loc_h = [(np.where(dist_mat[i] == proxim[i])[0][0]) for i in range(len(proxim))]

    #         cent_atom = hpos[loc_h]

    #         vect1 =  oxpos - cent_atom 
    #         vect2 = ocpos_comb[loc[i]] - cent_atom
    #         vect1 = vect1[0]
    #         vect2 = vect2[0]

    #         cosTheta = np.dot(vect1,vect2)/((np.linalg.norm(vect1))*np.linalg.norm(vect2))
    #         theta = np.rad2deg(np.arccos(cosTheta))

    #         angles.append(theta)

    #     return (interm_dist,angles)


    # def extract_atoms(self, distance_matrix, min_distance, max_distance):

    #     '''Determine the molecules that reside within a certain distance range 
    #     from the instantaneous interface.'''

    #     within_distance_range_mask = (distance_matrix >= min_distance) & (distance_matrix <= max_distance)
    #     within_distance_range_rows = np.any(within_distance_range_mask, axis=1)
    #     atoms_within_distance_range = np.where(within_distance_range_rows)[0]

    #     return atoms_within_distance_range

    # def co2_surf_dist(self, wc_inter, cpos, boxdim, min_distance, max_distance):

    #     '''Identify CO2s residing at the water surface using proximity to the instantaneous interface.'''

    #     try:
    #         dist_mat = distance_array(cpos, wc_inter, box=boxdim)
    #     except:
    #         dist_mat = distance_array(cpos, wc_inter, box=boxdim)
    #     loc = self.extract_atoms(dist_mat, min_distance, max_distance)


    #     co2_surf = [cpos[i] for i in loc]
    #     co2_surf = np.array(co2_surf)
    #     print(np.min(co2_surf[:,2]))
    #     print(np.max(co2_surf[:,2]))

    #     try:
    #         co2_dist = self_distance_array(co2_surf, box=boxdim)
    #         return co2_dist
    #     except:
    #         result = [0, 0]
    #         return result
    #         # do nothing if no co2 at the surface.
        

    # def co2_bond_angles_surf(self,wc,cpos,ocpos1,ocpos2,boxdim,min_distance,max_distance):

    #     try:
    #         dist_mat = distance_array(cpos,wc,box=boxdim)
    #     except:
    #         dist_mat = distance_array(cpos,np.array(wc),box=boxdim)
    #     loc = self.extract_atoms(dist_mat,min_distance,max_distance)

    #     c_surf = [cpos[i] for i in loc]
    #     oc1_surf = [ocpos1[i] for i in loc]
    #     oc2_surf = [ocpos2[i] for i in loc]
    #     c_surf = np.array(c_surf)
    #     oc1_surf = np.array(oc1_surf)
    #     oc2_surf = np.array(oc2_surf)

    #     vect_1 = distances.minimize_vectors(oc1_surf - c_surf,box=boxdim)
    #     vect_2 = distances.minimize_vectors(oc2_surf - c_surf,box=boxdim)

    #     dist,surf_vect = Density(self._u).proximity(wc,c_surf,boxdim,result='both',cutoff=False)

    #     theta_1 = self.calc_angles(vect_1,surf_vect)
    #     theta_2 = self.calc_angles(vect_2,surf_vect)

    #     output = np.concatenate((theta_1,theta_2))

    #     return output